# Архитектура кэширования отчетов (S3 + CDN)

## Проблема
Высокая нагрузка на OLAP (ClickHouse) из-за повторных запросов одних и тех же исторических отчетов пользователями.

## Решение
Внедрение слоя кэширования на базе объектного хранилища (S3) и CDN (Nginx).

### Компоненты

1.  **Minio (S3 Storage)**:
    *   Хранит сформированные JSON-файлы отчетов.
    *   Структура: `bucket-reports/{user_id}/{report_date}.json`.
    *   Обеспечивает долгосрочное хранение.

2.  **Nginx (CDN / Reverse Proxy)**:
    *   Стоит перед Minio.
    *   Кэширует ответы от Minio (статические файлы).
    *   Снижает нагрузку на S3 при "горячих" запросах (хотя S3 сам по себе масштабируем, Nginx снижает задержки и трафик).
    *   Отдает контент по HTTP.

3.  **Reports Service**:
    *   При запросе отчета проверяет наличие файла в S3.
    *   Если файл есть -> возвращает URL на CDN (`http://cdn-host/reports/...`).
    *   Если файла нет -> генерирует из ClickHouse, сохраняет в S3, возвращает URL.

### Алгоритм работы

1.  **Запрос**: Frontend -> BFF -> Reports Service (`GET /reports/user1`).
2.  **Проверка**: Reports Service вычисляет актуальную дату отчета (например, `2023-10-27`).
3.  **Поиск**: Reports Service делает `HEAD` запрос в S3 по ключу `user1/2023-10-27.json`.
4.  **Сценарий А (Hit)**: Файл найден. Service возвращает `{"report_url": "http://cdn/user1/2023-10-27.json"}`.
5.  **Сценарий Б (Miss)**:
    *   Service делает `SELECT` из ClickHouse.
    *   Формирует JSON.
    *   Загружает (`PUT`) в S3 `user1/2023-10-27.json`.
    *   Возвращает `{"report_url": "http://cdn/user1/2023-10-27.json"}`.
6.  **Получение данных**:
    *   Frontend видит `report_url`.
    *   Frontend делает `GET http://cdn/user1/2023-10-27.json`.
    *   Nginx проверяет свой кэш -> Minio -> Возвращает файл.

### Обновление кэша
Так как данные обновляются ETL процессом раз в сутки (ночью), то "актуальный" отчет — это отчет за вчерашний день (или сегодня, если real-time).
Для уникальности используем дату в имени файла. При наступлении нового дня имя файла меняется, старый остается в истории (или удаляется политикой ротации), а новый генерируется при первом запросе. Это обеспечивает автоматическую инвалидацию без сложной логики сброса кэша.
